import {
  HttpException,
  HttpStatus,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { In, Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { randomBytes } from 'crypto';
import { MailService } from '@modules/mail/mail.service';
import { readFileSync, unlinkSync, writeFileSync } from 'fs';
import { Member } from '@modules/member/entities/member.entity';
import { Staff } from '@modules/staffs/entities/staff.entity';

import { Role } from '@modules/roles/entities/role.entity';
import { CreateMemberDto } from '@modules/member/dto/create-member.dto';
import { Branch } from '@modules/branches/entities/branch.entity';
import { Service } from '@modules/services/entities/service.entity';
import { GenerateUniqueNumberUtil } from '@utils/generate-unique-number.util';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private _userRepository: Repository<User>,
    @InjectRepository(Member)
    private _memberRepository: Repository<Member>,

    @InjectRepository(Staff)
    private _staffRepository: Repository<Staff>,

    @InjectRepository(Branch)
    private _branchRepository: Repository<Branch>,

    @InjectRepository(Service)
    private _serviceRepository: Repository<Service>,

    @InjectRepository(Role)
    private _roleRepository: Repository<Role>,

    private _mailService: MailService,

    private readonly _generateUniqueNumberUtil: GenerateUniqueNumberUtil,
  ) {}

  generateRandomPassword(length: number = 12): string {
    const password = randomBytes(length / 2).toString('hex');
    return password;
  }
  async create(createUserDto: CreateUserDto, type?: string) {
    try {
      const existingUser = await this._userRepository.findOne({
        where: { email: createUserDto.email },
      });

      if (existingUser) {
        throw new HttpException(
          `The user with this email: ${createUserDto.email} have already exist!`,
          HttpStatus.CONFLICT,
        );
      }

      const userPassword =
        !createUserDto.password || type
          ? this.generateRandomPassword()
          : createUserDto.password;

      const { first_name, last_name, roleId, ...createUserData } =
        createUserDto;

      const username = await this.generateUniqueUsername();

      // const autoGeneratedPassword = randomBytes(8).toString('hex');
      const hashedPassword = await bcrypt.hash(userPassword, 10);

      const createdUser = this._userRepository.create({
        username,
        ...createUserData,
        roleId,
      });
      createdUser.password = hashedPassword;
      if (type === 'member') {
        const member = await this._memberRepository.findOne({
          where: { id: createUserDto.memberId },
        });

        if (!member) {
          throw new NotFoundException(`Member not found!`);
        }

        createdUser.memberId = member.id; // Assign memberId to the User entity
      } else if (type === 'staff') {
        const staff = await this._staffRepository.findOne({
          where: { id: createUserDto.staffId },
        });

        if (!staff) {
          throw new NotFoundException(`Staff with found!`);
        }

        createdUser.staffId = staff.id; // Assign staffId to the User entity
      } else {
        throw new HttpException(
          `Invalid user type: ${type}. Must be either 'member' or 'staff'.`,
          HttpStatus.BAD_REQUEST,
        );
      }

      if (type) {
        await this._mailService.sendMail(
          createUserDto.email, // Assuming username is the email
          'Welcome to Direna Health Support Platform!',
          `Hello ${first_name + ' ' + last_name},\n\nYour account has been created successfully. Here are your credentials:\n\nUsername: ${createUserDto.email}\nPassword: ${userPassword}\n\nPlease change your password after logging in.`,
        );
      }
      await this._userRepository.save(createdUser);

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...userCreated } = createdUser;
      return userCreated;
    } catch (error) {
      throw new HttpException(`${error.message}`, HttpStatus.BAD_REQUEST);
    }
  }

  async becomeAmember(
    updateUserToMemberDTO: CreateMemberDto,
    userData: { id: string; role: string },
  ): Promise<Member> {
    try {
      const user = await this._userRepository.findOne({
        where: { id: userData.id },
      });
      const existingRole = await this._roleRepository.findOne({
        where: { name: userData.role },
      });

      const { serviceIds, branchId, ...memberData } = updateUserToMemberDTO;

      const member = await this._memberRepository.findOne({
        where: { email: updateUserToMemberDTO.email },
      });

      const branch = await this._branchRepository.findOne({
        where: { id: branchId },
      });

      const newRole = await this._roleRepository.findOne({
        where: { name: 'Member' },
      });

      if (!user) {
        throw new NotFoundException('User not found');
      }
      if (member) {
        throw new HttpException('User already a member', HttpStatus.CONFLICT);
      }

      if (!branch) {
        throw new NotFoundException(`branch not found`);
      }

      if (!existingRole) {
        throw new NotFoundException('The Old Role not Exist  not found');
      }

      const services = await this._serviceRepository.find({
        where: {
          id: In(serviceIds), // Import In from typeorm
        },
      });

      if (services.length !== serviceIds.length) {
        throw new NotFoundException(`One or more services not found`);
      }

      const memberNumber =
        await this._generateUniqueNumberUtil.generateUniqueNumber(
          'DIRENA-MEM',
          this._memberRepository,
          'member_number',
        );

      const createdMember = this._memberRepository.create({
        ...memberData,
        member_number: memberNumber,
        branch,
        services,
      });

      this._userRepository.create({
        roleId: newRole.id,
      });

      return await this._memberRepository.save(createdMember);
    } catch (error) {
      throw new HttpException(
        `Failed to create!:${error.message}`,
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  async generateUniqueUsername(): Promise<string> {
    let username: string;
    let isUsernameTaken = true;

    while (isUsernameTaken) {
      const randomSuffix = Math.floor(Math.random() * 1000); // 0-999
      username = `DIRENA-USR-${randomSuffix}`;

      const existingUser = await this._userRepository.findOne({
        where: { username },
      });
      isUsernameTaken = !!existingUser;
    }

    return username;
  }

  // findAll() {
  //   return `This action returns all user`;
  // }

  async findOne(id: string) {
    try {
      const user = await this._userRepository.findOne({
        where: { id },
        relations: ['role'],
      });
      if (!user) {
        throw new NotFoundException(`user not found`);
      }

      return user;
    } catch (error) {
      throw new HttpException(error.message, HttpStatus.NOT_FOUND);
    }
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<User | any> {
    const user = await this._userRepository.findOne({ where: { id } });

    if (updateUserDto.username) {
      const existingUsername = await this._userRepository.findOne({
        where: { username: updateUserDto.username },
      });

      if (existingUsername) {
        throw new HttpException(
          `The username: ${updateUserDto.username} have already exist!`,
          HttpStatus.CONFLICT,
        );
      }
    }

    if (updateUserDto.email && updateUserDto.email !== user.email) {
      const existingEmail = await this._userRepository.findOne({
        where: { email: updateUserDto.email },
      });
      if (existingEmail) {
        throw new HttpException(
          `The email: ${updateUserDto.email} have already exist!`,
          HttpStatus.CONFLICT,
        );
      }
    }

    if (!user) {
      throw new NotFoundException(`user not found`);
    }

    if (updateUserDto.email) {
      user.email = updateUserDto.email;
    }
    if (updateUserDto.username) {
      user.username = updateUserDto.username;
    }

    if (updateUserDto.password) {
      user.password = await bcrypt.hash(updateUserDto.password, 10);
    }

    if (updateUserDto.first_name) {
      user.first_name = updateUserDto.first_name;
    }
    if (updateUserDto.middle_name) {
      user.middle_name = updateUserDto.middle_name;
    }

    if (updateUserDto.last_name) {
      user.last_name = updateUserDto.last_name;
    }
    if (updateUserDto.phone_number) {
      user.phone_number = updateUserDto.phone_number;
    }
    if (updateUserDto.gender) {
      user.gender = updateUserDto.gender;
    }

    await this._userRepository.save(user);

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...updateUserData } = user;

    return updateUserData;
  }

  async uploadUserAvatar(
    userId: string,
    file: Express.Multer.File,
  ): Promise<any> {
    try {
      const user = await this._userRepository.findOne({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException('User not found');
      }

      user.avatar = file.path;
      await this._userRepository.save(user);

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...userData } = user;

      return userData;
    } catch (error) {
      throw new HttpException(
        `Failed to upload avatar: ${error.message}`,
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  async updateUserAvatar(
    userId: string,
    file: Express.Multer.File,
  ): Promise<any> {
    try {
      const user = await this._userRepository.findOne({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException('User not found');
      }
      const oldPath = user.avatar;
      unlinkSync(oldPath);
      const newPath = file.path;
      const fileContent = readFileSync(file.path);

      writeFileSync(newPath, fileContent);

      user.avatar = newPath;
      await this._userRepository.save(user);
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...userData } = user;

      return userData;
    } catch (error) {
      throw new HttpException(
        `Failed to update avatar: ${error.message}`,
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  async findOneByUsername(username: string): Promise<User> {
    try {
      const user = await this._userRepository.findOne({
        where: { email: username },
        relations: ['role'],
      });
      if (!user) {
        throw new NotFoundException(`user not found`);
      }

      return user;
    } catch (error) {
      throw new HttpException(error.message, HttpStatus.NOT_FOUND);
    }
  }

  async findOneByEmail(email: string): Promise<User> {
    try {
      const user = await this._userRepository.findOne({
        where: { email },
        relations: ['role'],
      });
      if (!user) {
        throw new NotFoundException(`user not found`);
      }

      return user;
    } catch (error) {
      throw new HttpException(error.message, HttpStatus.NOT_FOUND);
    }
  }

  async getProfile(userId: string): Promise<any> {
    // Fetch the user without loading relationships initially
    const user = await this._userRepository.findOne({
      where: { id: userId },
      relations: [
        'role',
        // 'orders',
        // 'orders.items',
        // 'orders.items.equipment',
        // 'orders.items.equipment.files',
        // 'wishlists',
        // 'wishlists.equipment',
        // 'wishlists.equipment.files',
      ], // Always load the role
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    // Check if the user is a member or staff and load the relevant relationship
    if (user.memberId) {
      // Load the member relationship if the user is a member
      const member = await this._memberRepository.findOne({
        where: { id: user.memberId },
      });

      if (!member) {
        throw new NotFoundException('Member not found');
      }

      // Exclude staffId and staff from the response
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { staffId, staff, roleId, password, ...userData } = user;

      return {
        profile: userData, // Spread user data without staffId and staff
        member, // Include the member details
      };
    } else if (user.staffId) {
      // Load the staff relationship if the user is a staff
      const staff = await this._staffRepository.findOne({
        where: { id: user.staffId },
      });

      if (!staff) {
        throw new NotFoundException('Staff not found');
      }

      // Exclude memberId and member from the response
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { memberId, roleId, password, member, ...userData } = user;

      return {
        profile: userData, // Spread user data without memberId and member
        staff, // Include the staff details
      };
    } else {
      // If the user is neither a member nor a staff, return the user without relationships

      const {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        memberId,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        staffId,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        roleId,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        password,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        member,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        staff,
        ...userData
      } = user;

      return {
        profile: userData,
      };
    }
  }

  async remove(id: string, userType: string) {
    try {
      const user = await this._userRepository.findOne({
        where: { id },
      });

      if (userType === 'member') {
        const member = await this._memberRepository.findOne({
          where: { email: user.email },
        });

        if (!member) {
          throw new NotFoundException(
            'user email does not match the user email',
          );
        }

        member.isActive = false;

        await this._memberRepository.save(member);
      } else if (userType === 'staff') {
        const staff = await this._staffRepository.findOne({
          where: { email: user.email },
        });

        if (!staff) {
          throw new NotFoundException(
            'user email does not match the user email',
          );
        }

        staff.isActive = false;

        await this._staffRepository.save(staff);
      }

      if (!user) {
        throw new NotFoundException('User not found');
      }

      await this._userRepository.remove(user);

      return {
        message: `Successfully deleted your account`,
        status: 'success',
      };
    } catch (error) {
      throw new HttpException(
        {
          message: 'Failed to delete your account',
          error: error.message || 'Internal Server Error',
          status: 'error',
        },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
